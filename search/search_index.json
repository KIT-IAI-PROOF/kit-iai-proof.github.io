{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PROOF Documentation \u00b6 \u26a0\ufe0f Work in Progress This documentation is currently under active development. Some sections may be incomplete or subject to change. We are continuously working on improving and expanding the content. If you encounter any issues or have suggestions, please feel free to reach out to the development team. Introduction \u00b6 PROOF is a co-simulation framework that allows users to create and manage complex workflows. The PROOF UI provides a user-friendly interface for creating and managing workflows. Basic Docker knowledge is required to start and interact with the first version. Basic Execution Options \u00b6 PROOF is designed to run in the following environments: Docker : Use Docker to containerize your PROOF environment, making it easy to use on the system. Table of Contents \u00b6 Getting Started PROOF Overall Structure PROOF Workflows Workflow Structure Creating Workflows Monitoring Workflows PROOF Blocks and Templates Introduction Using Blocks Creating new Blocks PROOF UI Create a new Workflow Start a Workflow Monitor a running Workflow Configure Elements Configure a Workflow Configure a Block Template Configure a Program Configure an Attachment Frequently Asked Questions (FAQ) Documentation for Developers \u00b6 Creating Model Programs","title":"PROOF Documentation"},{"location":"#proof-documentation","text":"\u26a0\ufe0f Work in Progress This documentation is currently under active development. Some sections may be incomplete or subject to change. We are continuously working on improving and expanding the content. If you encounter any issues or have suggestions, please feel free to reach out to the development team.","title":"PROOF Documentation"},{"location":"#introduction","text":"PROOF is a co-simulation framework that allows users to create and manage complex workflows. The PROOF UI provides a user-friendly interface for creating and managing workflows. Basic Docker knowledge is required to start and interact with the first version.","title":"Introduction"},{"location":"#basic-execution-options","text":"PROOF is designed to run in the following environments: Docker : Use Docker to containerize your PROOF environment, making it easy to use on the system.","title":"Basic Execution Options"},{"location":"#table-of-contents","text":"Getting Started PROOF Overall Structure PROOF Workflows Workflow Structure Creating Workflows Monitoring Workflows PROOF Blocks and Templates Introduction Using Blocks Creating new Blocks PROOF UI Create a new Workflow Start a Workflow Monitor a running Workflow Configure Elements Configure a Workflow Configure a Block Template Configure a Program Configure an Attachment Frequently Asked Questions (FAQ)","title":"Table of Contents"},{"location":"#documentation-for-developers","text":"Creating Model Programs","title":"Documentation for Developers"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) \u00b6 Technical Questions \u00b6 How do I handle errors in my workflow? \u00b6 PROOF uses Notify Messages to communicate errors. When an error occurs, the orchestrator receives notification about the error location and reason. Check the monitoring panel and logs for error details. Troubleshooting \u00b6 My workflow won't start. What should I check? \u00b6 Ensure all required inputs are configured Check that all blocks are properly connected Verify that the workflow is saved Check the monitoring panel for error messages Review logs for detailed error information Blocks are not connecting. Why? \u00b6 Blocks can only connect if their inputs and outputs are compatible (same data type). Compatible connections are indicated by matching colors. Check that you're connecting compatible pin types. Where can I find logs? \u00b6 Logs are available in the Monitoring panel of the PROOF UI. Select a workflow execution to view its logs and status information. Getting Help \u00b6 Where can I find more documentation? \u00b6 Getting Started : Getting started with PROOF Structure : PROOF structure and concepts Blocks : Block structure and components Workflows : Workflow creation and management Programs : Program structure and creation Who should I contact for support? \u00b6 For questions, issues, or suggestions, please contact the PROOF development team at KIT (Karlsruhe Institute of Technology) at proof@iai.kit.edu .","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#technical-questions","text":"","title":"Technical Questions"},{"location":"faq/#how-do-i-handle-errors-in-my-workflow","text":"PROOF uses Notify Messages to communicate errors. When an error occurs, the orchestrator receives notification about the error location and reason. Check the monitoring panel and logs for error details.","title":"How do I handle errors in my workflow?"},{"location":"faq/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"faq/#my-workflow-wont-start-what-should-i-check","text":"Ensure all required inputs are configured Check that all blocks are properly connected Verify that the workflow is saved Check the monitoring panel for error messages Review logs for detailed error information","title":"My workflow won't start. What should I check?"},{"location":"faq/#blocks-are-not-connecting-why","text":"Blocks can only connect if their inputs and outputs are compatible (same data type). Compatible connections are indicated by matching colors. Check that you're connecting compatible pin types.","title":"Blocks are not connecting. Why?"},{"location":"faq/#where-can-i-find-logs","text":"Logs are available in the Monitoring panel of the PROOF UI. Select a workflow execution to view its logs and status information.","title":"Where can I find logs?"},{"location":"faq/#getting-help","text":"","title":"Getting Help"},{"location":"faq/#where-can-i-find-more-documentation","text":"Getting Started : Getting started with PROOF Structure : PROOF structure and concepts Blocks : Block structure and components Workflows : Workflow creation and management Programs : Program structure and creation","title":"Where can I find more documentation?"},{"location":"faq/#who-should-i-contact-for-support","text":"For questions, issues, or suggestions, please contact the PROOF development team at KIT (Karlsruhe Institute of Technology) at proof@iai.kit.edu .","title":"Who should I contact for support?"},{"location":"About/about/","text":"PROOF is a co-simulation platform under the license of KIT (Karlsruhe Institute of Technology) and MIT","title":"About"},{"location":"Block/creating-model-programs/","text":"Creating Model Programs \u00b6 Target audience: Developers PROOF provides the user with predefined Block Templates that can be used to create Blocks in Workflows . If a user wants to implement a specific functionality or model that is not covered by the existing Block Templates , it is possible to create new Block Templates . This page describes how to create own Model Programs that is required to build a new Block Template in PROOF. The process of creating new Block Templates in PROOF UI is described in the Creating new Block Templates documentation. What is a Model Program? \u00b6 A Model Program is an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed by a Block in PROOF. Since the current version of the PROOF Docker containers use Python as programming language for Model Programs , the following documentation refers to Python specifically. The extension to other programming languages (Java, MATLAB) will be provided in future releases of PROOF (2026). A Model Program must be able to run independently and perform the required computations to ensure it works as expected when integrated into a Block within a Workflow . The Model Program must be implemented as a subclass of the proofcore.base.basewrapper.BaseWrapper class and implements (overrides) the required methods for initialization ('init'), execution ('step'), and termination ('finalize'). To ease the generation of new Model Programs , a template Python script is provided in the PROOF GitHub repository proof-sim-core under proofcore/templates/WrapperTemplate.py . In PROOF, a Block Template defines the structure and functionality of a Block , i.e. a Block is an instance of a Template . Such a Block can be reused multiple times in different workflows. Creating a new Block Template involves several steps, including defining the Block's inputs, outputs, and execution logic. Creating new Templates offers the possibility to insert a desired behaviour or to implement specific functionalities or models to a Workflow. For this case you need to create a new Block Template that defines the structure and functionality of the block. This can be done with the PROOF UI and the menu config : Structure of a Template \u00b6 A Template consists of three main parts: A Program entity that represents the physical simulation model as an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed. Optionally, additional files or dependencies required for the model's execution. For Import/Export: A description file (in JSON format) that defines the block's metadata, inputs, outputs, and other configuration details. Steps to Create a New Template \u00b6 Develop the Program : Note: in PROOF version 1.0, only Python is supported. Therefore, the model file must be a Python script and the documentation hereafter refers to Python specifically. Create the executable model file that contains the model's logic. This file should be able to run independently and perform the required computations. For this, you can use any programming language supported by PROOF (e.g., Python, Java, MATLAB). This file will be the core of your Block Template . It can be built and should be able to be tested outside of PROOF to ensure it works as expected. The model file must be a subclass of proofcore.base.basewrapper.py and implement the required methods for initialization, execution ( step ), and termination. Identify Attachments Attachments are additional files or dependencies required for the model's execution. They are attached to the Program entity and can include configuration files, libraries, or other resources needed by the model. One Attachment must be the model file created in step 1. This Attachment is called the entry point of the Program entity. Additional Attachments can be added as needed. Define the Template Metadata This step is only needed, if you want to import the Template from a JSON file and not create it directly in the PROOF UI. For this, you need to create a JSON file that defines the Template's metadata, including its ID, label, description, inputs, outputs, and other configuration details. Further, the Program and the Attachments must be defined in the JSON file, too. The fixed structure of the JSON file is described in the PROOF JSON Schema documentation . Create a Template in PROOF UI \u00b6 To create a new Template in the PROOF UI, follow these steps: ( Note: ) It's recommended to create the Attachments at first, followed by the Program creation and finally the Template creation. Select the Config menu on the left side of the UI. Here you can select the desired button for the configuration or creation of new elements. Create Attachments : Click on the Attachments button to open the Attachments management interface . Click on the \" + ADD \" button to create a new Attachment . Fill in the required fields, such as ID, label, description, and upload the model file. Save the Attachment . Repeat this process for any additional Attachments needed for the Program . Create a Program : Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program . Create a Template : Click on the Templates button to open the Templates management interface . Click on the \" + ADD \" button to create a new Template . Fill in the required fields, such as ID, label, description, and select the previously created Program . Define the inputs and outputs of the Template according to the model's requirements. Save the Template . After having created a new Template , it can be used immediately to instantiate Blocks in Workflows using the PROOF Workflow Editor . You can find the Template in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas.","title":"Creating Model Programs"},{"location":"Block/creating-model-programs/#creating-model-programs","text":"Target audience: Developers PROOF provides the user with predefined Block Templates that can be used to create Blocks in Workflows . If a user wants to implement a specific functionality or model that is not covered by the existing Block Templates , it is possible to create new Block Templates . This page describes how to create own Model Programs that is required to build a new Block Template in PROOF. The process of creating new Block Templates in PROOF UI is described in the Creating new Block Templates documentation.","title":"Creating Model Programs"},{"location":"Block/creating-model-programs/#what-is-a-model-program","text":"A Model Program is an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed by a Block in PROOF. Since the current version of the PROOF Docker containers use Python as programming language for Model Programs , the following documentation refers to Python specifically. The extension to other programming languages (Java, MATLAB) will be provided in future releases of PROOF (2026). A Model Program must be able to run independently and perform the required computations to ensure it works as expected when integrated into a Block within a Workflow . The Model Program must be implemented as a subclass of the proofcore.base.basewrapper.BaseWrapper class and implements (overrides) the required methods for initialization ('init'), execution ('step'), and termination ('finalize'). To ease the generation of new Model Programs , a template Python script is provided in the PROOF GitHub repository proof-sim-core under proofcore/templates/WrapperTemplate.py . In PROOF, a Block Template defines the structure and functionality of a Block , i.e. a Block is an instance of a Template . Such a Block can be reused multiple times in different workflows. Creating a new Block Template involves several steps, including defining the Block's inputs, outputs, and execution logic. Creating new Templates offers the possibility to insert a desired behaviour or to implement specific functionalities or models to a Workflow. For this case you need to create a new Block Template that defines the structure and functionality of the block. This can be done with the PROOF UI and the menu config :","title":"What is a Model Program?"},{"location":"Block/creating-model-programs/#structure-of-a-template","text":"A Template consists of three main parts: A Program entity that represents the physical simulation model as an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed. Optionally, additional files or dependencies required for the model's execution. For Import/Export: A description file (in JSON format) that defines the block's metadata, inputs, outputs, and other configuration details.","title":"Structure of a Template"},{"location":"Block/creating-model-programs/#steps-to-create-a-new-template","text":"Develop the Program : Note: in PROOF version 1.0, only Python is supported. Therefore, the model file must be a Python script and the documentation hereafter refers to Python specifically. Create the executable model file that contains the model's logic. This file should be able to run independently and perform the required computations. For this, you can use any programming language supported by PROOF (e.g., Python, Java, MATLAB). This file will be the core of your Block Template . It can be built and should be able to be tested outside of PROOF to ensure it works as expected. The model file must be a subclass of proofcore.base.basewrapper.py and implement the required methods for initialization, execution ( step ), and termination. Identify Attachments Attachments are additional files or dependencies required for the model's execution. They are attached to the Program entity and can include configuration files, libraries, or other resources needed by the model. One Attachment must be the model file created in step 1. This Attachment is called the entry point of the Program entity. Additional Attachments can be added as needed. Define the Template Metadata This step is only needed, if you want to import the Template from a JSON file and not create it directly in the PROOF UI. For this, you need to create a JSON file that defines the Template's metadata, including its ID, label, description, inputs, outputs, and other configuration details. Further, the Program and the Attachments must be defined in the JSON file, too. The fixed structure of the JSON file is described in the PROOF JSON Schema documentation .","title":"Steps to Create a New Template"},{"location":"Block/creating-model-programs/#create-a-template-in-proof-ui","text":"To create a new Template in the PROOF UI, follow these steps: ( Note: ) It's recommended to create the Attachments at first, followed by the Program creation and finally the Template creation. Select the Config menu on the left side of the UI. Here you can select the desired button for the configuration or creation of new elements. Create Attachments : Click on the Attachments button to open the Attachments management interface . Click on the \" + ADD \" button to create a new Attachment . Fill in the required fields, such as ID, label, description, and upload the model file. Save the Attachment . Repeat this process for any additional Attachments needed for the Program . Create a Program : Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program . Create a Template : Click on the Templates button to open the Templates management interface . Click on the \" + ADD \" button to create a new Template . Fill in the required fields, such as ID, label, description, and select the previously created Program . Define the inputs and outputs of the Template according to the model's requirements. Save the Template . After having created a new Template , it can be used immediately to instantiate Blocks in Workflows using the PROOF Workflow Editor . You can find the Template in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas.","title":"Create a Template in PROOF UI"},{"location":"Block/creating-new-templates/","text":"Creating new Block Templates \u00b6 In PROOF, a Block Template defines the structure and functionality of a Block , i.e. a Block is an instance of a Template . Such a Block can be reused multiple times in different workflows. Creating a new Block Template involves several steps, including defining the Block's inputs, outputs, and execution logic. Creating new Templates offers the possibility to insert a desired behaviour or to implement specific functionalities or models to a Workflow. For this case you need to create a new Block Template that defines the structure and functionality of the block. This can be done with the PROOF UI and the menu config : Structure of a Template \u00b6 A Template consists of three main parts: A Program entity that represents the physical simulation model as an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed. Optionally, additional files or dependencies required for the model's execution. For Import/Export: A description file (in JSON format) that defines the block's metadata, inputs, outputs, and other configuration details. json-structure-of-a-block.md Steps to Create a New Template \u00b6 Develop the Program : Note: in PROOF version 1.0, only Python is supported. Therefore, the model file must be a Python script and the documentation hereafter refers to Python specifically. Create the executable model file that contains the model's logic. This file should be able to run independently and perform the required computations. For this, you can use any programming language supported by PROOF (e.g., Python, Java, MATLAB). This file will be the core of your Block Template . It can be built and should be able to be tested outside of PROOF to ensure it works as expected. The model file must be a subclass of proofcore.base.basewrapper.py and implement the required methods for initialization, execution ( step ), and termination. Identify Attachments Attachments are additional files or dependencies required for the model's execution. They are attached to the Program entity and can include configuration files, libraries, or other resources needed by the model. One Attachment must be the model file created in step 1. This Attachment is called the entry point of the Program entity. Additional Attachments can be added as needed. Create a Template in PROOF UI \u00b6 To create a new Template in the PROOF UI, follow these steps: ( Note: ) It's recommended to create the Attachments at first, followed by the Program creation and finally the Template creation. Select the Config menu on the left side of the UI. Here you can select the desired button for the configuration or creation of new elements. Create Attachments : Click on the Attachments button to open the Attachments management interface . Click on the \" + ADD \" button to create a new Attachment . Fill in the required fields, such as ID, label, description, and upload the model file. Save the Attachment . Repeat this process for any additional Attachments needed for the Program . Create a Program : Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program . Create a Template : Click on the Templates button to open the Templates management interface . Click on the \" + ADD \" button to create a new Template . Fill in the required fields, such as ID, label, description, and select the previously created Program . Define the inputs and outputs of the Template according to the model's requirements. Save the Template . After having created a new Template , it can be used immediately to instantiate Blocks in Workflows using the PROOF Workflow Editor . You can find the Template in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas.","title":"Creating new Blocks"},{"location":"Block/creating-new-templates/#creating-new-block-templates","text":"In PROOF, a Block Template defines the structure and functionality of a Block , i.e. a Block is an instance of a Template . Such a Block can be reused multiple times in different workflows. Creating a new Block Template involves several steps, including defining the Block's inputs, outputs, and execution logic. Creating new Templates offers the possibility to insert a desired behaviour or to implement specific functionalities or models to a Workflow. For this case you need to create a new Block Template that defines the structure and functionality of the block. This can be done with the PROOF UI and the menu config :","title":"Creating new Block Templates"},{"location":"Block/creating-new-templates/#structure-of-a-template","text":"A Template consists of three main parts: A Program entity that represents the physical simulation model as an executable file (such as a Python script, Java program, or MATLAB script) that contains the logic to be executed. Optionally, additional files or dependencies required for the model's execution. For Import/Export: A description file (in JSON format) that defines the block's metadata, inputs, outputs, and other configuration details. json-structure-of-a-block.md","title":"Structure of a Template"},{"location":"Block/creating-new-templates/#steps-to-create-a-new-template","text":"Develop the Program : Note: in PROOF version 1.0, only Python is supported. Therefore, the model file must be a Python script and the documentation hereafter refers to Python specifically. Create the executable model file that contains the model's logic. This file should be able to run independently and perform the required computations. For this, you can use any programming language supported by PROOF (e.g., Python, Java, MATLAB). This file will be the core of your Block Template . It can be built and should be able to be tested outside of PROOF to ensure it works as expected. The model file must be a subclass of proofcore.base.basewrapper.py and implement the required methods for initialization, execution ( step ), and termination. Identify Attachments Attachments are additional files or dependencies required for the model's execution. They are attached to the Program entity and can include configuration files, libraries, or other resources needed by the model. One Attachment must be the model file created in step 1. This Attachment is called the entry point of the Program entity. Additional Attachments can be added as needed.","title":"Steps to Create a New Template"},{"location":"Block/creating-new-templates/#create-a-template-in-proof-ui","text":"To create a new Template in the PROOF UI, follow these steps: ( Note: ) It's recommended to create the Attachments at first, followed by the Program creation and finally the Template creation. Select the Config menu on the left side of the UI. Here you can select the desired button for the configuration or creation of new elements. Create Attachments : Click on the Attachments button to open the Attachments management interface . Click on the \" + ADD \" button to create a new Attachment . Fill in the required fields, such as ID, label, description, and upload the model file. Save the Attachment . Repeat this process for any additional Attachments needed for the Program . Create a Program : Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program . Create a Template : Click on the Templates button to open the Templates management interface . Click on the \" + ADD \" button to create a new Template . Fill in the required fields, such as ID, label, description, and select the previously created Program . Define the inputs and outputs of the Template according to the model's requirements. Save the Template . After having created a new Template , it can be used immediately to instantiate Blocks in Workflows using the PROOF Workflow Editor . You can find the Template in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas.","title":"Create a Template in PROOF UI"},{"location":"Block/overview/","text":"PROOF Blocks and Templates \u00b6 Blocks \u00b6 Blocks are functional nodes in the Workflow schedule. Each Block delivers functionality, receives input data, and creates output data used by other Blocks. Each computational model/executable (such as Python, Java, MATLAB and Functional Mock-up Unit) is represented as a Block with its dependencies (e.g., libraries, solvers, and configurations). This information is used when combining multiple Blocks into a Workflow to ensure interfaces work together. The description holds information about the executable/model and how life cycles and events triggered by the Orchestrator should be handled. This information/instructions are integrated into a Python script to define the Block's life cycle, such as initialization, execution, and termination, along with commands for handling input and output data. Templates \u00b6 Blocks are created from templates, which are reusable definitions of Blocks that can be instantiated multiple times. This can be compared to classes in object-oriented programming, where a class defines the structure and behavior, and an unlimited number of instances can be built from that class. This means for the UI, that a Block is created when a Template is dragged onto the canvas. Block Components \u00b6 Blocks consist of several components that define their structure and functionality. The main components of a Block are Worker, Wrapper, Inputs, Outputs, and Communication via Messages (Events) . Worker \u00b6 Target audience: Developers The Worker is the core component of a Block that executes the main functionality. It is responsible for running the model or executable associated with the Block and can be regarded as the neutral part of the Block. It handles the execution logic, including initialization, execution, and termination of the model or executable. Wrapper \u00b6 Target audience: Developers The Wrapper is the model itself that can be realized in various programming languages such as Python, Java, or MATLAB. It is started by the Worker as a background process and is responsible for executing the model's logic and serves as a bridge between the Worker and the model, providing the necessary interface for the Worker to interact with the model. The Wrapper contains the logic for handling inputs and outputs, as well as any additional configuration or dependencies required by the model. Inputs \u00b6 Inputs are the data that a Block receives from other Blocks or external sources. There are two types of inputs: Dynamic Inputs : These are the actual data that the Block needs to process. They can be of various types, such as numerical values, strings, or complex data structures. Static Data Inputs : These are parameters or settings for the initialization of the Wrapper at startup. They are not changed during the execution of the Block and are used to configure the Worker's behavior. Both types of inputs can be required or optional , depending on the Block's definition (see Creating new Blocks and Templates ). Outputs \u00b6 Outputs are the data that a Block produces after processing the inputs. Similar to inputs, outputs can be of various types. They are used to connect Blocks in a Workflow. The outputs of one Block can be used as inputs for another Block, allowing for data flow between Blocks in a Workflow. Communication via Messages \u00b6 The communication between Blocks and the orchestrator is done via messages, which are events that trigger specific actions in the Blocks. Messages are used to notify Blocks about changes in the state of the Workflow, such as the completion of a Block's execution or the availability of new data. There are three types of messages: Synchronization Messages (SYNC) \u00b6 These messages are sent to the workers by the orchestrator to synchronize the simulation process. Different synchronization messages exist for the several simulation phases: Initialization Messages (INIT) : The orchestrator sends these messages to the Workers to initialize the Blocks with the necessary (static) inputs and configuration. Execution Messages (EXECUTE) are sent to the Workers to start the execution of the Block's logic. Execution Messages are sent multiple times during the simulation process. Finalization Messages (FINALIZE) are sent to the Workers to terminate the Block's execution. Shutdown Messages (SHUTDOWN) are sent to the Workers to clean up resources. Value Messages (VALUE) \u00b6 They are used to transfer data between Blocks. They can contain the actual data that the Block needs to process or the results of the Block's execution. Notify Messages (NOTIFY) \u00b6 They are used to notify the orchestrator when a Block has finished the simulation step and other Blocks about errors that occur during the execution of a Block. They contain information about the status of a Block and the Wrapper, too, when a Block ... has finished the INIT phase to indicate that it is ready for execution. has finished the EXECUTE phase to indicate that it is ready for the next step. has finished the FINALIZE phase to indicate that it is ready for shutdown. has finished the SHUTDOWN phase to indicate that it is ready for cleanup. or it provides information about the reason and position of an error and how to handle it when an error occurred during any phase of a Block. See also: Creating new Blocks and Templates Creating Model Programs Testing Blocks and its Program","title":"Introduction"},{"location":"Block/overview/#proof-blocks-and-templates","text":"","title":"PROOF Blocks and Templates"},{"location":"Block/overview/#blocks","text":"Blocks are functional nodes in the Workflow schedule. Each Block delivers functionality, receives input data, and creates output data used by other Blocks. Each computational model/executable (such as Python, Java, MATLAB and Functional Mock-up Unit) is represented as a Block with its dependencies (e.g., libraries, solvers, and configurations). This information is used when combining multiple Blocks into a Workflow to ensure interfaces work together. The description holds information about the executable/model and how life cycles and events triggered by the Orchestrator should be handled. This information/instructions are integrated into a Python script to define the Block's life cycle, such as initialization, execution, and termination, along with commands for handling input and output data.","title":"Blocks"},{"location":"Block/overview/#templates","text":"Blocks are created from templates, which are reusable definitions of Blocks that can be instantiated multiple times. This can be compared to classes in object-oriented programming, where a class defines the structure and behavior, and an unlimited number of instances can be built from that class. This means for the UI, that a Block is created when a Template is dragged onto the canvas.","title":"Templates"},{"location":"Block/overview/#block-components","text":"Blocks consist of several components that define their structure and functionality. The main components of a Block are Worker, Wrapper, Inputs, Outputs, and Communication via Messages (Events) .","title":"Block Components"},{"location":"Block/overview/#worker","text":"Target audience: Developers The Worker is the core component of a Block that executes the main functionality. It is responsible for running the model or executable associated with the Block and can be regarded as the neutral part of the Block. It handles the execution logic, including initialization, execution, and termination of the model or executable.","title":"Worker"},{"location":"Block/overview/#wrapper","text":"Target audience: Developers The Wrapper is the model itself that can be realized in various programming languages such as Python, Java, or MATLAB. It is started by the Worker as a background process and is responsible for executing the model's logic and serves as a bridge between the Worker and the model, providing the necessary interface for the Worker to interact with the model. The Wrapper contains the logic for handling inputs and outputs, as well as any additional configuration or dependencies required by the model.","title":"Wrapper"},{"location":"Block/overview/#inputs","text":"Inputs are the data that a Block receives from other Blocks or external sources. There are two types of inputs: Dynamic Inputs : These are the actual data that the Block needs to process. They can be of various types, such as numerical values, strings, or complex data structures. Static Data Inputs : These are parameters or settings for the initialization of the Wrapper at startup. They are not changed during the execution of the Block and are used to configure the Worker's behavior. Both types of inputs can be required or optional , depending on the Block's definition (see Creating new Blocks and Templates ).","title":"Inputs"},{"location":"Block/overview/#outputs","text":"Outputs are the data that a Block produces after processing the inputs. Similar to inputs, outputs can be of various types. They are used to connect Blocks in a Workflow. The outputs of one Block can be used as inputs for another Block, allowing for data flow between Blocks in a Workflow.","title":"Outputs"},{"location":"Block/overview/#communication-via-messages","text":"The communication between Blocks and the orchestrator is done via messages, which are events that trigger specific actions in the Blocks. Messages are used to notify Blocks about changes in the state of the Workflow, such as the completion of a Block's execution or the availability of new data. There are three types of messages:","title":"Communication via Messages"},{"location":"Block/overview/#synchronization-messages-sync","text":"These messages are sent to the workers by the orchestrator to synchronize the simulation process. Different synchronization messages exist for the several simulation phases: Initialization Messages (INIT) : The orchestrator sends these messages to the Workers to initialize the Blocks with the necessary (static) inputs and configuration. Execution Messages (EXECUTE) are sent to the Workers to start the execution of the Block's logic. Execution Messages are sent multiple times during the simulation process. Finalization Messages (FINALIZE) are sent to the Workers to terminate the Block's execution. Shutdown Messages (SHUTDOWN) are sent to the Workers to clean up resources.","title":"Synchronization Messages (SYNC)"},{"location":"Block/overview/#value-messages-value","text":"They are used to transfer data between Blocks. They can contain the actual data that the Block needs to process or the results of the Block's execution.","title":"Value Messages (VALUE)"},{"location":"Block/overview/#notify-messages-notify","text":"They are used to notify the orchestrator when a Block has finished the simulation step and other Blocks about errors that occur during the execution of a Block. They contain information about the status of a Block and the Wrapper, too, when a Block ... has finished the INIT phase to indicate that it is ready for execution. has finished the EXECUTE phase to indicate that it is ready for the next step. has finished the FINALIZE phase to indicate that it is ready for shutdown. has finished the SHUTDOWN phase to indicate that it is ready for cleanup. or it provides information about the reason and position of an error and how to handle it when an error occurred during any phase of a Block. See also: Creating new Blocks and Templates Creating Model Programs Testing Blocks and its Program","title":"Notify Messages (NOTIFY)"},{"location":"Block/proof-blocks/","text":"PROOF Blocks (Templates) \u00b6 kann weg","title":"PROOF Blocks (Templates)"},{"location":"Block/proof-blocks/#proof-blocks-templates","text":"kann weg","title":"PROOF Blocks (Templates)"},{"location":"GettingStarted/getting-started/","text":"Prerequisites \u00b6 To run PROOF in different environments, ensure you have the following prerequisites installed: Execution with Docker \u00b6 The Docker environment (Docker engine) must be installed on your host system. To install docker and to see more information about docker, please follow the instructions on the docker homepage: www.docker.com . Alternatively, you can install docker by using the command line and the package sources for your corresponding operations system distribution. Windows: Follow the official docker documentation . All other required components are provided via Docker images. Exception: If you want to create your own Blocks , you need to have Python, Java, or MATLAB installed on your host system to create and test the model programs. Installation \u00b6 Follow these steps to start and run PROOF. Get proof-environment \u00b6 To install PROOF, move to the repository proof-environment and clone the repository to your local file system. We recommend creating a PROOF directory for this purpose. To clone the repository using a cli, make sure you have git installed on your local machine. Alternatively, you can download the zip-file of proof-environment. Download the worker image \u00b6 The docker image for the (python) worker needs to be downloaded manually using the following command in a terminal/command line: docker pull ghcr.io/kit-iai-proof/proof-worker-python:1.0.0 Start PROOF \u00b6 To start PROOF, navigate to the following folder within proof-environment: cd proof-environment/docker Afterwards, start PROOF using the compose file in the docker folder: docker compose up Windows: Ensure to have the Docker Desktop App running. PROOF will take a few moments to be started properly. Thus, you can access the PROOF graphical user interface by opening a new browser window/tab and type the following in the URL address bar: localhost:80 Due to caching behaviour in some browsers, we strongly recommend opening the PROOF UI in a private browser window at this moment. To access the workflow creation editor, the credentials to be used are test/test . Data exchange \u00b6 Data exchange with PROOF currently works via the proof-environment/data folder. All files laying in this folder can be accessed e.g. in the FileLineProvider block to be read from. Test your installation \u00b6 To test your installation, you can use the workflow FileReader2FileWriter . It contains two blocks: the FileReader which reads a file given as input parameter and provides the next line each step and the FileWriter which receives data and appends it to the file which name is given as an input parameter. When you see in the Orchestrator logs that all blocks are shutdown, can can check the contents of the output file (e.g. out.txt ) which should be the same as the input.txt file. cd proof-environment/data cat out.txt","title":"Getting Started"},{"location":"GettingStarted/getting-started/#prerequisites","text":"To run PROOF in different environments, ensure you have the following prerequisites installed:","title":"Prerequisites"},{"location":"GettingStarted/getting-started/#execution-with-docker","text":"The Docker environment (Docker engine) must be installed on your host system. To install docker and to see more information about docker, please follow the instructions on the docker homepage: www.docker.com . Alternatively, you can install docker by using the command line and the package sources for your corresponding operations system distribution. Windows: Follow the official docker documentation . All other required components are provided via Docker images. Exception: If you want to create your own Blocks , you need to have Python, Java, or MATLAB installed on your host system to create and test the model programs.","title":"Execution with Docker"},{"location":"GettingStarted/getting-started/#installation","text":"Follow these steps to start and run PROOF.","title":"Installation"},{"location":"GettingStarted/getting-started/#get-proof-environment","text":"To install PROOF, move to the repository proof-environment and clone the repository to your local file system. We recommend creating a PROOF directory for this purpose. To clone the repository using a cli, make sure you have git installed on your local machine. Alternatively, you can download the zip-file of proof-environment.","title":"Get proof-environment"},{"location":"GettingStarted/getting-started/#download-the-worker-image","text":"The docker image for the (python) worker needs to be downloaded manually using the following command in a terminal/command line: docker pull ghcr.io/kit-iai-proof/proof-worker-python:1.0.0","title":"Download the worker image"},{"location":"GettingStarted/getting-started/#start-proof","text":"To start PROOF, navigate to the following folder within proof-environment: cd proof-environment/docker Afterwards, start PROOF using the compose file in the docker folder: docker compose up Windows: Ensure to have the Docker Desktop App running. PROOF will take a few moments to be started properly. Thus, you can access the PROOF graphical user interface by opening a new browser window/tab and type the following in the URL address bar: localhost:80 Due to caching behaviour in some browsers, we strongly recommend opening the PROOF UI in a private browser window at this moment. To access the workflow creation editor, the credentials to be used are test/test .","title":"Start PROOF"},{"location":"GettingStarted/getting-started/#data-exchange","text":"Data exchange with PROOF currently works via the proof-environment/data folder. All files laying in this folder can be accessed e.g. in the FileLineProvider block to be read from.","title":"Data exchange"},{"location":"GettingStarted/getting-started/#test-your-installation","text":"To test your installation, you can use the workflow FileReader2FileWriter . It contains two blocks: the FileReader which reads a file given as input parameter and provides the next line each step and the FileWriter which receives data and appends it to the file which name is given as an input parameter. When you see in the Orchestrator logs that all blocks are shutdown, can can check the contents of the output file (e.g. out.txt ) which should be the same as the input.txt file. cd proof-environment/data cat out.txt","title":"Test your installation"},{"location":"ImportExport/import-and-export-of-elements/","text":"Import and Export of PROOF Elements \u00b6 PROOF provides functionality to import and export various elements such as Workflows , Block Templates , Programs , and Attachments . This allows users to easily share and reuse these elements across different PROOF instances or projects. The PROOF elements are ordered hierarchically, meaning that some elements rely on others to function correctly. The hierarchy is as follows: Workflows : The top-level element that defines the overall process and structure of a simulation or analysis. Blocks : The building blocks of a Workflow , which define specific tasks or operations to be performed. Programs : The executable code or scripts that are associated with Blocks to perform specific functions. Attachments : Additional files or resources that are required by Programs to execute correctly. All elements are defined using a JSON structure, which includes metadata, configurations, and references to dependent elements. This standardized format allows for easy import and export of elements between different PROOF instances. For more details on the JSON structure of each element, please refer to the respective documentation sections: JSON Structure of a Workflow JSON Structure of a Block A PROOF Workflow can be exported as a JSON file that contains all the necessary information about the workflow, including its structure, references to *Blocks\", connections, and configurations. This JSON file can then be imported into another PROOF instance to recreate the same workflow.","title":"Import and Export of PROOF Elements"},{"location":"ImportExport/import-and-export-of-elements/#import-and-export-of-proof-elements","text":"PROOF provides functionality to import and export various elements such as Workflows , Block Templates , Programs , and Attachments . This allows users to easily share and reuse these elements across different PROOF instances or projects. The PROOF elements are ordered hierarchically, meaning that some elements rely on others to function correctly. The hierarchy is as follows: Workflows : The top-level element that defines the overall process and structure of a simulation or analysis. Blocks : The building blocks of a Workflow , which define specific tasks or operations to be performed. Programs : The executable code or scripts that are associated with Blocks to perform specific functions. Attachments : Additional files or resources that are required by Programs to execute correctly. All elements are defined using a JSON structure, which includes metadata, configurations, and references to dependent elements. This standardized format allows for easy import and export of elements between different PROOF instances. For more details on the JSON structure of each element, please refer to the respective documentation sections: JSON Structure of a Workflow JSON Structure of a Block A PROOF Workflow can be exported as a JSON file that contains all the necessary information about the workflow, including its structure, references to *Blocks\", connections, and configurations. This JSON file can then be imported into another PROOF instance to recreate the same workflow.","title":"Import and Export of PROOF Elements"},{"location":"Program/proof-programs/","text":"PROOF Programs \u00b6 program \u00b6 A Program is a reusable set of files and executables. Generic Programs can be used in multiple Blocks with different Block descriptions and interfaces. A Program consists of at least one standalone executable file performing at runtime. Further dependencies for running the executable, e.g., configuration files, solvers, libraries or licenses, are integrated as attachments. Structure of a Program \u00b6 A Program consists of three main parts: Steps to Create a New Program \u00b6 Create a Template in PROOF UI \u00b6 Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program .","title":"PROOF Programs"},{"location":"Program/proof-programs/#proof-programs","text":"","title":"PROOF Programs"},{"location":"Program/proof-programs/#program","text":"A Program is a reusable set of files and executables. Generic Programs can be used in multiple Blocks with different Block descriptions and interfaces. A Program consists of at least one standalone executable file performing at runtime. Further dependencies for running the executable, e.g., configuration files, solvers, libraries or licenses, are integrated as attachments.","title":"program"},{"location":"Program/proof-programs/#structure-of-a-program","text":"A Program consists of three main parts:","title":"Structure of a Program"},{"location":"Program/proof-programs/#steps-to-create-a-new-program","text":"","title":"Steps to Create a New Program"},{"location":"Program/proof-programs/#create-a-template-in-proof-ui","text":"Click on the Programs button to open the Programs management interface . Click on the \" + ADD \" button to create a new Program . Fill in the required fields, such as ID, label, description, and select the previously created Attachments . Specify which Attachment is the entry point (the model file). Save the Program .","title":"Create a Template in PROOF UI"},{"location":"Structure/json-element-structures/","text":"JSON Structure of PROOF Elements \u00b6 JSON structure of a Workflow \u00b6 For the import and export of PROOF Workflows , a JSON structure is used to define the Workflow's metadata and the references to associated Blocks . A Workflow JSON file typically includes the following key components: Workflow Metadata : This section contains general information about the Workflow , such as its ID, name, description, etc. Blocks : This section contains an array of Block references that are part of the Workflow . Each Block reference includes its unique identifier and configuration details. Connections : This section defines the connections between the Blocks in the Workflow , specifying how data flows from one Block to another. Parameters : This section includes any additional parameters or settings required for the Workflow execution. Here is as an example the JSON structure for the PROOF Workflow FileReader2FileWriter : { \"id\": \"WF-FileReader2FileWriter\", \"name\": \"FileReader2FileWriter-Test\", \"description\": \"The FileReader2FileWriter demo workflow reads an arbitrary file and writes the content to another file.\", \"communicationParadigm\": \"STEPBASED\", \"blocks\": [ { \"localId\": 0, \"globalId\": \"block_file_line_provider\", }, { \"localId\": 1, \"globalId\": \"block_file_writer\" } ], \"connections\": [ { \"inbound\": { \"blockId\": \"0\", \"portName\": \"line\" }, \"outbound\": { \"blockId\": \"1\", \"portName\": \"data\" } } ], \"stepBasedConfig\": { \"startPoint\": 1, \"endPoint\": 10, \"duration\": 500, \"stepSizeDefinitions\": { \"1\": { \"startPoint\": 2, \"endPoint\": 10, \"defaultSize\": 1, \"stepSizes\": {} } } }, \"simulationStrategy\": \"WAIT_AND_CONTINUE\" } This JSON structure can be used to import the Workflow into a PROOF installation or export it for sharing with others. It is assumed that the referenced blocks already exist in th e PROOF database when the workflow is imported. @TODO : Add link to 'import workflows'. Description of the JSON Fields \u00b6 id : A unique identifier for the Workflow . name : The display name of the Workflow . description : A brief description of the Workflow's functionality. communicationParadigm : The communication paradigm used in the Workflow (e.g., STEPBASED). blocks : An array of Block references included in the Workflow . Each entry contains: localId : A unique local identifier for the Block within the Workflow . globalId : The global identifier of the Block template used. connections : An array defining the connections between the referenced Blocks . Each connection includes: inbound : The localId of the source Block and port name. The port name must match the name of an output name of the source Block . outbound : The localId of the destination Block and port name. The port name must match the name of an input name of the target Block . stepBasedConfig : Configuration details specific to step-based communication, including start and end points, duration, and step size definitions. simulationStrategy : The strategy used for simulation execution (e.g., WAIT_AND_CONTINUE). JSON structure of a Block \u00b6 For the import and export of PROOF Blocks , a JSON structure is used to define the Block's metadata, inputs, outputs, and other configuration details. This structure allows for easy sharing and reuse of Blocks across different PROOF installations. A Block JSON file typically includes the following key components: Block Metadata : This section contains general information about the Block , such as its ID, label, etc. Inputs : This section defines the inputs that the Block accepts, including their names, types, and whether they are required or optional. Outputs : This section defines the outputs that the Block produces, including their names and types. Here is as an example the JSON structure for the PROOF Block FileWriter : { \"id\": \"block_file_writer\", \"name\": \"File Writer\", \"description\": \"Write data to a file\", \"containerImage\": \"ghcr.io/kit-iai-proof/proof-worker-python:1.0.0\", \"communicationParadigm\": \"STEPBASED\", \"programId\": \"prog_file_writer\", \"inputs\": [ { \"name\": \"file name\", \"type\": \"string\", \"phase\": \"INIT\", \"required\": true, \"modelVarname\": \"file_name\", \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"mode\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"mode\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"waitForSync\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"waitForSync\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"data\", \"type\": \"string\", \"phase\": \"EXECUTE\", \"modelVarname\": \"data\", \"required\": false, \"communicationType\": \"STEPBASED\", \"metadata\": {} } ], \"outputs\": [], \"startParameters\": {} } This JSON structure can be used to import the Block into a PROOF installation or export it for sharing with others. The defined inputs and outputs ensure that the Block can be correctly integrated into PROOF Workflows . Description of the JSON Fields \u00b6 id : A unique identifier for the Block . name : The display name of the Block . description : A brief description of the Block's functionality. containerImage : The Docker container image used to run the Block . communicationParadigm : The communication paradigm used by the Block (e.g., STEPBASED). programId : The identifier of the Program associated with the Block . This is an own JSON file. inputs : An array of input definitions for the Block . Each input includes: name : The visible name of the input. type : The data type of the input (e.g., string, integer). phase : The phase during which the input is used (e.g., INIT, EXECUTE). required : A boolean indicating whether the input is required at startup. modelVarname : The variable name used in the model for this input. In most cases, it matches the name. communicationType : The type of communication for this input (e.g., STEPBASED_STATIC, STEPBASED). metadata : Additional metadata for the input (can be any structure or empty). outputs : An array of output definitions for the Block . Each output includes: name : The visible name of the output. type : The data type of the output (e.g., string, integer). phase : The phase during which the output is produced (e.g., EXECUTE). modelVarname : The variable name used in the model for this output. In most cases, it matches the name. communicationType : The type of communication for this output (e.g., STEPBASED). metadata : Additional metadata for the output (can be any structure or empty). startParameters : A section for any additional parameters needed at the start and run of the Block (can be empty). JSON structure of a Program \u00b6 For the import and export of PROOF Programs , a JSON structure is used to define the Program's metadata, associated Attachments , and other configuration details. This structure allows for easy sharing and reuse of Programs across different PROOF installations. A Program JSON file typically includes the following key components: - Program Metadata : This section contains general information about the Program , such as its ID, label, description, etc. - Attachments : This section defines the Attachments associated with the Program , including the entry point file and any additional files required for execution. Here is as an example the JSON structure for the PROOF Program FileWriter : { \"id\": \"prog_file_writer\", \"name\": \"prog_file_writer\", \"description\": \"write data to a file\", \"tag\": \"test\", \"runtime\": \"PYTHON\", \"entryPoint\": \"attachment_file_writer\", \"attachments\": [ { \"id\": \"attachment_file_writer\" } ] } This JSON structure can be used to import the Program into a PROOF installation or export it for sharing with others. The defined Attachments ensure that the Program has all the necessary files for execution. Description of the JSON Fields \u00b6 id : A unique identifier for the Program . name : The display name of the Program . description : A brief description of the Program's functionality. tag : A tag or label for the Program (can be used for categorization). runtime : The runtime environment for the Program (e.g., PYTHON, JAVA). entryPoint : The identifier of the Attachment that serves as the entry point for the Program (i.e., the main executable file). attachments : An array of Attachment definitions associated with the Program . Each attachment includes: id : The unique identifier of the Attachment . JSON Structure of an Attachment \u00b6 For the import and export of PROOF Attachments , a JSON structure is used to define the Attachment's metadata and file information. This structure allows for easy sharing and reuse of Attachments across different PROOF installations. A Attachment JSON file typically includes the following key components: - Attachment Metadata : This section contains general information about the Attachment , such as its ID, label, description, etc. - File Information : This section defines the file associated with the Attachment , including its name and type. Here is as an example the JSON structure for the PROOF Attachment FileWriter : { \"id\": \"attachment_file_writer\", \"fileName\": \"file_writer.py\", \"description\": \"write data to a file\" }","title":"JSON Structure of PROOF Elements"},{"location":"Structure/json-element-structures/#json-structure-of-proof-elements","text":"","title":"JSON Structure of PROOF Elements"},{"location":"Structure/json-element-structures/#json-structure-of-a-workflow","text":"For the import and export of PROOF Workflows , a JSON structure is used to define the Workflow's metadata and the references to associated Blocks . A Workflow JSON file typically includes the following key components: Workflow Metadata : This section contains general information about the Workflow , such as its ID, name, description, etc. Blocks : This section contains an array of Block references that are part of the Workflow . Each Block reference includes its unique identifier and configuration details. Connections : This section defines the connections between the Blocks in the Workflow , specifying how data flows from one Block to another. Parameters : This section includes any additional parameters or settings required for the Workflow execution. Here is as an example the JSON structure for the PROOF Workflow FileReader2FileWriter : { \"id\": \"WF-FileReader2FileWriter\", \"name\": \"FileReader2FileWriter-Test\", \"description\": \"The FileReader2FileWriter demo workflow reads an arbitrary file and writes the content to another file.\", \"communicationParadigm\": \"STEPBASED\", \"blocks\": [ { \"localId\": 0, \"globalId\": \"block_file_line_provider\", }, { \"localId\": 1, \"globalId\": \"block_file_writer\" } ], \"connections\": [ { \"inbound\": { \"blockId\": \"0\", \"portName\": \"line\" }, \"outbound\": { \"blockId\": \"1\", \"portName\": \"data\" } } ], \"stepBasedConfig\": { \"startPoint\": 1, \"endPoint\": 10, \"duration\": 500, \"stepSizeDefinitions\": { \"1\": { \"startPoint\": 2, \"endPoint\": 10, \"defaultSize\": 1, \"stepSizes\": {} } } }, \"simulationStrategy\": \"WAIT_AND_CONTINUE\" } This JSON structure can be used to import the Workflow into a PROOF installation or export it for sharing with others. It is assumed that the referenced blocks already exist in th e PROOF database when the workflow is imported. @TODO : Add link to 'import workflows'.","title":"JSON structure of a Workflow"},{"location":"Structure/json-element-structures/#description-of-the-json-fields","text":"id : A unique identifier for the Workflow . name : The display name of the Workflow . description : A brief description of the Workflow's functionality. communicationParadigm : The communication paradigm used in the Workflow (e.g., STEPBASED). blocks : An array of Block references included in the Workflow . Each entry contains: localId : A unique local identifier for the Block within the Workflow . globalId : The global identifier of the Block template used. connections : An array defining the connections between the referenced Blocks . Each connection includes: inbound : The localId of the source Block and port name. The port name must match the name of an output name of the source Block . outbound : The localId of the destination Block and port name. The port name must match the name of an input name of the target Block . stepBasedConfig : Configuration details specific to step-based communication, including start and end points, duration, and step size definitions. simulationStrategy : The strategy used for simulation execution (e.g., WAIT_AND_CONTINUE).","title":"Description of the JSON Fields"},{"location":"Structure/json-element-structures/#json-structure-of-a-block","text":"For the import and export of PROOF Blocks , a JSON structure is used to define the Block's metadata, inputs, outputs, and other configuration details. This structure allows for easy sharing and reuse of Blocks across different PROOF installations. A Block JSON file typically includes the following key components: Block Metadata : This section contains general information about the Block , such as its ID, label, etc. Inputs : This section defines the inputs that the Block accepts, including their names, types, and whether they are required or optional. Outputs : This section defines the outputs that the Block produces, including their names and types. Here is as an example the JSON structure for the PROOF Block FileWriter : { \"id\": \"block_file_writer\", \"name\": \"File Writer\", \"description\": \"Write data to a file\", \"containerImage\": \"ghcr.io/kit-iai-proof/proof-worker-python:1.0.0\", \"communicationParadigm\": \"STEPBASED\", \"programId\": \"prog_file_writer\", \"inputs\": [ { \"name\": \"file name\", \"type\": \"string\", \"phase\": \"INIT\", \"required\": true, \"modelVarname\": \"file_name\", \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"mode\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"mode\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"waitForSync\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"waitForSync\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"data\", \"type\": \"string\", \"phase\": \"EXECUTE\", \"modelVarname\": \"data\", \"required\": false, \"communicationType\": \"STEPBASED\", \"metadata\": {} } ], \"outputs\": [], \"startParameters\": {} } This JSON structure can be used to import the Block into a PROOF installation or export it for sharing with others. The defined inputs and outputs ensure that the Block can be correctly integrated into PROOF Workflows .","title":"JSON structure of a Block"},{"location":"Structure/json-element-structures/#description-of-the-json-fields_1","text":"id : A unique identifier for the Block . name : The display name of the Block . description : A brief description of the Block's functionality. containerImage : The Docker container image used to run the Block . communicationParadigm : The communication paradigm used by the Block (e.g., STEPBASED). programId : The identifier of the Program associated with the Block . This is an own JSON file. inputs : An array of input definitions for the Block . Each input includes: name : The visible name of the input. type : The data type of the input (e.g., string, integer). phase : The phase during which the input is used (e.g., INIT, EXECUTE). required : A boolean indicating whether the input is required at startup. modelVarname : The variable name used in the model for this input. In most cases, it matches the name. communicationType : The type of communication for this input (e.g., STEPBASED_STATIC, STEPBASED). metadata : Additional metadata for the input (can be any structure or empty). outputs : An array of output definitions for the Block . Each output includes: name : The visible name of the output. type : The data type of the output (e.g., string, integer). phase : The phase during which the output is produced (e.g., EXECUTE). modelVarname : The variable name used in the model for this output. In most cases, it matches the name. communicationType : The type of communication for this output (e.g., STEPBASED). metadata : Additional metadata for the output (can be any structure or empty). startParameters : A section for any additional parameters needed at the start and run of the Block (can be empty).","title":"Description of the JSON Fields"},{"location":"Structure/json-element-structures/#json-structure-of-a-program","text":"For the import and export of PROOF Programs , a JSON structure is used to define the Program's metadata, associated Attachments , and other configuration details. This structure allows for easy sharing and reuse of Programs across different PROOF installations. A Program JSON file typically includes the following key components: - Program Metadata : This section contains general information about the Program , such as its ID, label, description, etc. - Attachments : This section defines the Attachments associated with the Program , including the entry point file and any additional files required for execution. Here is as an example the JSON structure for the PROOF Program FileWriter : { \"id\": \"prog_file_writer\", \"name\": \"prog_file_writer\", \"description\": \"write data to a file\", \"tag\": \"test\", \"runtime\": \"PYTHON\", \"entryPoint\": \"attachment_file_writer\", \"attachments\": [ { \"id\": \"attachment_file_writer\" } ] } This JSON structure can be used to import the Program into a PROOF installation or export it for sharing with others. The defined Attachments ensure that the Program has all the necessary files for execution.","title":"JSON structure of a Program"},{"location":"Structure/json-element-structures/#description-of-the-json-fields_2","text":"id : A unique identifier for the Program . name : The display name of the Program . description : A brief description of the Program's functionality. tag : A tag or label for the Program (can be used for categorization). runtime : The runtime environment for the Program (e.g., PYTHON, JAVA). entryPoint : The identifier of the Attachment that serves as the entry point for the Program (i.e., the main executable file). attachments : An array of Attachment definitions associated with the Program . Each attachment includes: id : The unique identifier of the Attachment .","title":"Description of the JSON Fields"},{"location":"Structure/json-element-structures/#json-structure-of-an-attachment","text":"For the import and export of PROOF Attachments , a JSON structure is used to define the Attachment's metadata and file information. This structure allows for easy sharing and reuse of Attachments across different PROOF installations. A Attachment JSON file typically includes the following key components: - Attachment Metadata : This section contains general information about the Attachment , such as its ID, label, description, etc. - File Information : This section defines the file associated with the Attachment , including its name and type. Here is as an example the JSON structure for the PROOF Attachment FileWriter : { \"id\": \"attachment_file_writer\", \"fileName\": \"file_writer.py\", \"description\": \"write data to a file\" }","title":"JSON Structure of an Attachment"},{"location":"Structure/json-structure-of-a-block/","text":"JSON structure of a Block \u00b6 For the import and export of PROOF Blocks , a JSON structure is used to define the Block's metadata, inputs, outputs, and other configuration details. This structure allows for easy sharing and reuse of Blocks across different PROOF installations. A Block JSON file typically includes the following key components: Block Metadata : This section contains general information about the Block , such as its ID, label, etc. Inputs : This section defines the inputs that the Block accepts, including their names, types, and whether they are required or optional. Outputs : This section defines the outputs that the Block produces, including their names and types. Here is as an example the JSON structure for the PROOF Block FileWriter : { \"id\": \"block_file_writer\", \"name\": \"File Writer\", \"description\": \"Write data to a file\", \"containerImage\": \"ghcr.io/kit-iai-proof/proof-worker-python:1.0.0\", \"communicationParadigm\": \"STEPBASED\", \"programId\": \"prog_file_writer\", \"inputs\": [ { \"name\": \"file name\", \"type\": \"string\", \"phase\": \"INIT\", \"required\": true, \"modelVarname\": \"file_name\", \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"mode\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"mode\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"waitForSync\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"waitForSync\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"data\", \"type\": \"string\", \"phase\": \"EXECUTE\", \"modelVarname\": \"data\", \"required\": false, \"communicationType\": \"STEPBASED\", \"metadata\": {} } ], \"outputs\": [], \"startParameters\": {} } This JSON structure can be used to import the Block into a PROOF installation or export it for sharing with others. The defined inputs and outputs ensure that the Block can be correctly integrated into PROOF Workflows . Description of the JSON Fields \u00b6 id : A unique identifier for the Block . name : The display name of the Block . description : A brief description of the Block's functionality. containerImage : The Docker container image used to run the Block . communicationParadigm : The communication paradigm used by the Block (e.g., STEPBASED). programId : The identifier of the Program associated with the Block . This is an own JSON file. inputs : An array of input definitions for the Block . Each input includes: name : The visible name of the input. type : The data type of the input (e.g., string, integer). phase : The phase during which the input is used (e.g., INIT, EXECUTE). required : A boolean indicating whether the input is required at startup. modelVarname : The variable name used in the model for this input. In most cases, it matches the name. communicationType : The type of communication for this input (e.g., STEPBASED_STATIC, STEPBASED). metadata : Additional metadata for the input (can be any structure or empty). outputs : An array of output definitions for the Block . Each output includes: name : The visible name of the output. type : The data type of the output (e.g., string, integer). phase : The phase during which the output is produced (e.g., EXECUTE). modelVarname : The variable name used in the model for this output. In most cases, it matches the name. communicationType : The type of communication for this output (e.g., STEPBASED). metadata : Additional metadata for the output (can be any structure or empty). startParameters : A section for any additional parameters needed at the start and run of the Block (can be empty).","title":"JSON structure of a Block"},{"location":"Structure/json-structure-of-a-block/#json-structure-of-a-block","text":"For the import and export of PROOF Blocks , a JSON structure is used to define the Block's metadata, inputs, outputs, and other configuration details. This structure allows for easy sharing and reuse of Blocks across different PROOF installations. A Block JSON file typically includes the following key components: Block Metadata : This section contains general information about the Block , such as its ID, label, etc. Inputs : This section defines the inputs that the Block accepts, including their names, types, and whether they are required or optional. Outputs : This section defines the outputs that the Block produces, including their names and types. Here is as an example the JSON structure for the PROOF Block FileWriter : { \"id\": \"block_file_writer\", \"name\": \"File Writer\", \"description\": \"Write data to a file\", \"containerImage\": \"ghcr.io/kit-iai-proof/proof-worker-python:1.0.0\", \"communicationParadigm\": \"STEPBASED\", \"programId\": \"prog_file_writer\", \"inputs\": [ { \"name\": \"file name\", \"type\": \"string\", \"phase\": \"INIT\", \"required\": true, \"modelVarname\": \"file_name\", \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"mode\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"mode\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"waitForSync\", \"type\": \"string\", \"phase\": \"INIT\", \"modelVarname\": \"waitForSync\", \"required\": false, \"communicationType\": \"STEPBASED_STATIC\", \"metadata\": {} }, { \"name\": \"data\", \"type\": \"string\", \"phase\": \"EXECUTE\", \"modelVarname\": \"data\", \"required\": false, \"communicationType\": \"STEPBASED\", \"metadata\": {} } ], \"outputs\": [], \"startParameters\": {} } This JSON structure can be used to import the Block into a PROOF installation or export it for sharing with others. The defined inputs and outputs ensure that the Block can be correctly integrated into PROOF Workflows .","title":"JSON structure of a Block"},{"location":"Structure/json-structure-of-a-block/#description-of-the-json-fields","text":"id : A unique identifier for the Block . name : The display name of the Block . description : A brief description of the Block's functionality. containerImage : The Docker container image used to run the Block . communicationParadigm : The communication paradigm used by the Block (e.g., STEPBASED). programId : The identifier of the Program associated with the Block . This is an own JSON file. inputs : An array of input definitions for the Block . Each input includes: name : The visible name of the input. type : The data type of the input (e.g., string, integer). phase : The phase during which the input is used (e.g., INIT, EXECUTE). required : A boolean indicating whether the input is required at startup. modelVarname : The variable name used in the model for this input. In most cases, it matches the name. communicationType : The type of communication for this input (e.g., STEPBASED_STATIC, STEPBASED). metadata : Additional metadata for the input (can be any structure or empty). outputs : An array of output definitions for the Block . Each output includes: name : The visible name of the output. type : The data type of the output (e.g., string, integer). phase : The phase during which the output is produced (e.g., EXECUTE). modelVarname : The variable name used in the model for this output. In most cases, it matches the name. communicationType : The type of communication for this output (e.g., STEPBASED). metadata : Additional metadata for the output (can be any structure or empty). startParameters : A section for any additional parameters needed at the start and run of the Block (can be empty).","title":"Description of the JSON Fields"},{"location":"Structure/json-structure-of-a-workflow/","text":"JSON structure of a Workflow \u00b6 For the import and export of PROOF Workflows , a JSON structure is used to define the Workflow's metadata and the references to associated Blocks . A Workflow JSON file typically includes the following key components: Workflow Metadata : This section contains general information about the Workflow , such as its ID, name, description, etc. Blocks : This section contains an array of Block references that are part of the Workflow . Each Block reference includes its unique identifier and configuration details. Connections : This section defines the connections between the Blocks in the Workflow , specifying how data flows from one Block to another. Parameters : This section includes any additional parameters or settings required for the Workflow execution. Here is as an example the JSON structure for the PROOF Workflow FileReader2FileWriter : { \"id\": \"WF-FileReader2FileWriter\", \"name\": \"FileReader2FileWriter-Test\", \"description\": \"The FileReader2FileWriter demo workflow reads an arbitrary file and writes the content to another file.\", \"communicationParadigm\": \"STEPBASED\", \"blocks\": [ { \"localId\": 0, \"globalId\": \"block_file_line_provider\", }, { \"localId\": 1, \"globalId\": \"block_file_writer\" } ], \"connections\": [ { \"inbound\": { \"blockId\": \"0\", \"portName\": \"line\" }, \"outbound\": { \"blockId\": \"1\", \"portName\": \"data\" } } ], \"stepBasedConfig\": { \"startPoint\": 1, \"endPoint\": 10, \"duration\": 500, \"stepSizeDefinitions\": { \"1\": { \"startPoint\": 2, \"endPoint\": 10, \"defaultSize\": 1, \"stepSizes\": {} } } }, \"simulationStrategy\": \"WAIT_AND_CONTINUE\" } This JSON structure can be used to import the Workflow into a PROOF installation or export it for sharing with others. It is assumed that the referenced blocks already exist in th e PROOF database when the workflow is imported. @TODO : Add link to 'import workflows'. Description of the JSON Fields \u00b6 id : A unique identifier for the Workflow . name : The display name of the Workflow . description : A brief description of the Workflow's functionality. communicationParadigm : The communication paradigm used in the Workflow (e.g., STEPBASED). blocks : An array of Block references included in the Workflow . Each entry contains: localId : A unique local identifier for the Block within the Workflow . globalId : The global identifier of the Block template used. connections : An array defining the connections between the referenced Blocks . Each connection includes: inbound : The localId of the source Block and port name. The port name must match the name of an output name of the source Block . outbound : The localId of the destination Block and port name. The port name must match the name of an input name of the target Block . stepBasedConfig : Configuration details specific to step-based communication, including start and end points, duration, and step size definitions. simulationStrategy : The strategy used for simulation execution (e.g., WAIT_AND_CONTINUE).","title":"JSON structure of a Workflow"},{"location":"Structure/json-structure-of-a-workflow/#json-structure-of-a-workflow","text":"For the import and export of PROOF Workflows , a JSON structure is used to define the Workflow's metadata and the references to associated Blocks . A Workflow JSON file typically includes the following key components: Workflow Metadata : This section contains general information about the Workflow , such as its ID, name, description, etc. Blocks : This section contains an array of Block references that are part of the Workflow . Each Block reference includes its unique identifier and configuration details. Connections : This section defines the connections between the Blocks in the Workflow , specifying how data flows from one Block to another. Parameters : This section includes any additional parameters or settings required for the Workflow execution. Here is as an example the JSON structure for the PROOF Workflow FileReader2FileWriter : { \"id\": \"WF-FileReader2FileWriter\", \"name\": \"FileReader2FileWriter-Test\", \"description\": \"The FileReader2FileWriter demo workflow reads an arbitrary file and writes the content to another file.\", \"communicationParadigm\": \"STEPBASED\", \"blocks\": [ { \"localId\": 0, \"globalId\": \"block_file_line_provider\", }, { \"localId\": 1, \"globalId\": \"block_file_writer\" } ], \"connections\": [ { \"inbound\": { \"blockId\": \"0\", \"portName\": \"line\" }, \"outbound\": { \"blockId\": \"1\", \"portName\": \"data\" } } ], \"stepBasedConfig\": { \"startPoint\": 1, \"endPoint\": 10, \"duration\": 500, \"stepSizeDefinitions\": { \"1\": { \"startPoint\": 2, \"endPoint\": 10, \"defaultSize\": 1, \"stepSizes\": {} } } }, \"simulationStrategy\": \"WAIT_AND_CONTINUE\" } This JSON structure can be used to import the Workflow into a PROOF installation or export it for sharing with others. It is assumed that the referenced blocks already exist in th e PROOF database when the workflow is imported. @TODO : Add link to 'import workflows'.","title":"JSON structure of a Workflow"},{"location":"Structure/json-structure-of-a-workflow/#description-of-the-json-fields","text":"id : A unique identifier for the Workflow . name : The display name of the Workflow . description : A brief description of the Workflow's functionality. communicationParadigm : The communication paradigm used in the Workflow (e.g., STEPBASED). blocks : An array of Block references included in the Workflow . Each entry contains: localId : A unique local identifier for the Block within the Workflow . globalId : The global identifier of the Block template used. connections : An array defining the connections between the referenced Blocks . Each connection includes: inbound : The localId of the source Block and port name. The port name must match the name of an output name of the source Block . outbound : The localId of the destination Block and port name. The port name must match the name of an input name of the target Block . stepBasedConfig : Configuration details specific to step-based communication, including start and end points, duration, and step size definitions. simulationStrategy : The strategy used for simulation execution (e.g., WAIT_AND_CONTINUE).","title":"Description of the JSON Fields"},{"location":"Structure/proof-structure/","text":"PROOF Overall Structure \u00b6 Target audience: Users and Developers PROOF is structured around the concept of Workflows and Blocks . There are six main components: Workflows \u00b6 A workflow is a sequence of Blocks that are executed in a specific order. It defines how data flows between Blocks and how they are connected. A Workflow can be created, started, stopped, and monitored via the PROOF UI. Blocks (Templates) \u00b6 A Block is a reusable unit of functionality that can be used multiple times in a single Workflow and in multiple Workflows . It is a copy of a Block Template , i.e., the structure and functionality is defined by the Template and can be reproduced as often as required, Each Block has its own inputs, outputs, and execution logic. A Block can be connected with other Blocks , whereas output pins can be connected with input pins of another Block . UI \u00b6 The user interface (UI) provides a visual representation of Workflows and Blocks , allowing users to create, edit, and monitor Workflows easily. It allows users to create new Workflows by dragging and dropping Blocks from a template library onto a workflow canvas. Users can connect Blocks by linking their input and output pins to define the data flow between them. It provides configuration panels for Workflows and Blocks , allowing users to set parameters and options for each component. Orchestrator \u00b6 The Orchestrator is built as a web service and is responsible for managing the execution of a Workflow and its Blocks , handling communication between them, and ensuring that the simulation runs controlled and efficiently. It creates the communication queues to the Workers via a message broker (RabbitMQ) and prepares the communication between the Workers in RabbitMQ, too. The Orchestrator starts (and stops) a Workflow by receiving a start (stop) message from the PROOF UI. During a simulation the Orchestrator sends synchronisation messages (SYNC) to the Workers to initiate the next simulation step. It waits for notify messages (NOTIFY) sent by the Workers when they have finished a step or a simulation phase (initialization, execution, finalization, and shutdown). Worker \u00b6 The Worker is responsible for executing the logic of each Block , including running the model (i.e. the executable) associated with the Block . During initialization, the Worker starts the model program (Python, Java, or Matlab) as a background process. During the simulation, the Worker communicates with the model program. starts processing the model while it receives synchronisation messages (SYNC) from the Orchestrator and sends notify messages (NOTIFY) back to the Orchestrator when it has finished a simulation step or phase. Models \u00b6 Models are the underlying programs or scripts that are executed by the Blocks . They can be written in various programming languages such as Python, Java, or MATLAB.","title":"PROOF Overall Structure"},{"location":"Structure/proof-structure/#proof-overall-structure","text":"Target audience: Users and Developers PROOF is structured around the concept of Workflows and Blocks . There are six main components:","title":"PROOF Overall Structure"},{"location":"Structure/proof-structure/#workflows","text":"A workflow is a sequence of Blocks that are executed in a specific order. It defines how data flows between Blocks and how they are connected. A Workflow can be created, started, stopped, and monitored via the PROOF UI.","title":"Workflows"},{"location":"Structure/proof-structure/#blocks-templates","text":"A Block is a reusable unit of functionality that can be used multiple times in a single Workflow and in multiple Workflows . It is a copy of a Block Template , i.e., the structure and functionality is defined by the Template and can be reproduced as often as required, Each Block has its own inputs, outputs, and execution logic. A Block can be connected with other Blocks , whereas output pins can be connected with input pins of another Block .","title":"Blocks (Templates)"},{"location":"Structure/proof-structure/#ui","text":"The user interface (UI) provides a visual representation of Workflows and Blocks , allowing users to create, edit, and monitor Workflows easily. It allows users to create new Workflows by dragging and dropping Blocks from a template library onto a workflow canvas. Users can connect Blocks by linking their input and output pins to define the data flow between them. It provides configuration panels for Workflows and Blocks , allowing users to set parameters and options for each component.","title":"UI"},{"location":"Structure/proof-structure/#orchestrator","text":"The Orchestrator is built as a web service and is responsible for managing the execution of a Workflow and its Blocks , handling communication between them, and ensuring that the simulation runs controlled and efficiently. It creates the communication queues to the Workers via a message broker (RabbitMQ) and prepares the communication between the Workers in RabbitMQ, too. The Orchestrator starts (and stops) a Workflow by receiving a start (stop) message from the PROOF UI. During a simulation the Orchestrator sends synchronisation messages (SYNC) to the Workers to initiate the next simulation step. It waits for notify messages (NOTIFY) sent by the Workers when they have finished a step or a simulation phase (initialization, execution, finalization, and shutdown).","title":"Orchestrator"},{"location":"Structure/proof-structure/#worker","text":"The Worker is responsible for executing the logic of each Block , including running the model (i.e. the executable) associated with the Block . During initialization, the Worker starts the model program (Python, Java, or Matlab) as a background process. During the simulation, the Worker communicates with the model program. starts processing the model while it receives synchronisation messages (SYNC) from the Orchestrator and sends notify messages (NOTIFY) back to the Orchestrator when it has finished a simulation step or phase.","title":"Worker"},{"location":"Structure/proof-structure/#models","text":"Models are the underlying programs or scripts that are executed by the Blocks . They can be written in various programming languages such as Python, Java, or MATLAB.","title":"Models"},{"location":"UI/configs/","text":"Configuration \u00b6 The Configs Tab is the main interface for managing config files of workflows, templates, programs, and attachments in PROOF. It provides four interfaces for allowing users to operate config files, such as upload, edit, and delete. 1. Workflow Configs \u00b6 This interface allows you to manage the config files of workflows. 2. Templates Configs \u00b6 This interface allows you to manage the config files of templates. 3. Programs Configs \u00b6 This interface allows you to manage the config files of programs. 4. Attachments Configs \u00b6 This interface allows you to manage the config files of attachments.","title":"Configuration"},{"location":"UI/configs/#configuration","text":"The Configs Tab is the main interface for managing config files of workflows, templates, programs, and attachments in PROOF. It provides four interfaces for allowing users to operate config files, such as upload, edit, and delete.","title":"Configuration"},{"location":"UI/configs/#1-workflow-configs","text":"This interface allows you to manage the config files of workflows.","title":"1. Workflow Configs"},{"location":"UI/configs/#2-templates-configs","text":"This interface allows you to manage the config files of templates.","title":"2. Templates Configs"},{"location":"UI/configs/#3-programs-configs","text":"This interface allows you to manage the config files of programs.","title":"3. Programs Configs"},{"location":"UI/configs/#4-attachments-configs","text":"This interface allows you to manage the config files of attachments.","title":"4. Attachments Configs"},{"location":"UI/creating-workflows/","text":"Create a Workflow in PROOF UI \u00b6 On the proof UI, you can create new PROOF Workflows by selecting the Workflow Editor from the menu. The Workflow Editor is the main interface for creating and managing Workflows in PROOF. It provides a visual representation of the Workflow structure, allowing users to drag and drop Blocks, connect them, and configure their settings. Add a new Workflow \u00b6 You can create a new Workflow by clicking on the \" + \" button in the Workflow Editor to the right of the Workflow combo box . This opens a new empty Workflow canvas where you can start building your Workflow. Add PROOF Blocks to the Workflow from Block Templates \u00b6 You can drag and drop Block Templates from the right sidebar onto the Workflow canvas. Each Block Template represents a predefined specific functionality or model that can be used in the Workflow. A Block is created as an instance of the Block Template when it is added to the Workflow. The connectable inputs and outputs of each Block are represented by small circles on the left and right sides of the Block, respectively. Connect Blocks \u00b6 You can connect Blocks by clicking on the output of one Block and dragging it to the input of another Block. This establishes a data flow between the Blocks, allowing them to communicate and share data. When trying to connect Blocks, only compatible input and output pins are connectable. Compatible pins have the same color and data type. Configure Workflow Settings \u00b6 You can configure the settings of the Workflow by clicking on the \"Settings\" button in the top right corner of the Workflow Editor. This allows you to set ID, label, description, paradigm, and asynchronous Action for the entire Workflow. By clicking on the \"save\" button, the Workflow settings are saved. Configure Block Settings \u00b6 You can configure the Name of each Block by clicking on it and accessing the Block configuration panel. It is not possible to change the basic functionality of a Block, as it is defined by the Block Template. It is possible to change nearly all Template attributes as well as the associated Program and Attachments using the Template Configuration panel. Save the Workflow \u00b6 Once you have built your Workflow, you must save it by clicking on the \"Save\" button in the top right corner of the Workflow Editor. This saves the Workflow to the PROOF database, making it available for execution and further editing. Executing the Workflow via Workflow Editor \u00b6 After having saved the Workflow, you can execute it by navigating to the RUN button in the top right corner of the Workflow editor. You must enter all relevant Execution values in the pop-up execution dialog, such as Execution ID, Description, and other parameters specific to the Workflow. Executing the Workflow via Monitoring Panel \u00b6 You can also start a saved Workflow from the Workflow Monitoring panel in the PROOF UI. Click the Workflow Monitoring menu item in the left menu bar to open the monitoring interface. Press the \"RUN Workflow\" button in the top right corner of the Workflow Monitoring interface. A Combo box appears listing all saved Workflows. Select the saved Workflow from the list and click on the \"Start\" button to initiate the execution. Enter all necessary attribute values in the pop-up execution dialog, such as Execution Label, Description, and all start values for the given Inputs. Monitor the execution progress and view results through the Workflow Monitoring interface.","title":"Creating Workflows"},{"location":"UI/creating-workflows/#create-a-workflow-in-proof-ui","text":"On the proof UI, you can create new PROOF Workflows by selecting the Workflow Editor from the menu. The Workflow Editor is the main interface for creating and managing Workflows in PROOF. It provides a visual representation of the Workflow structure, allowing users to drag and drop Blocks, connect them, and configure their settings.","title":"Create a Workflow in PROOF UI"},{"location":"UI/creating-workflows/#add-a-new-workflow","text":"You can create a new Workflow by clicking on the \" + \" button in the Workflow Editor to the right of the Workflow combo box . This opens a new empty Workflow canvas where you can start building your Workflow.","title":"Add a new Workflow"},{"location":"UI/creating-workflows/#add-proof-blocks-to-the-workflow-from-block-templates","text":"You can drag and drop Block Templates from the right sidebar onto the Workflow canvas. Each Block Template represents a predefined specific functionality or model that can be used in the Workflow. A Block is created as an instance of the Block Template when it is added to the Workflow. The connectable inputs and outputs of each Block are represented by small circles on the left and right sides of the Block, respectively.","title":"Add PROOF Blocks to the Workflow from Block Templates"},{"location":"UI/creating-workflows/#connect-blocks","text":"You can connect Blocks by clicking on the output of one Block and dragging it to the input of another Block. This establishes a data flow between the Blocks, allowing them to communicate and share data. When trying to connect Blocks, only compatible input and output pins are connectable. Compatible pins have the same color and data type.","title":"Connect Blocks"},{"location":"UI/creating-workflows/#configure-workflow-settings","text":"You can configure the settings of the Workflow by clicking on the \"Settings\" button in the top right corner of the Workflow Editor. This allows you to set ID, label, description, paradigm, and asynchronous Action for the entire Workflow. By clicking on the \"save\" button, the Workflow settings are saved.","title":"Configure Workflow Settings"},{"location":"UI/creating-workflows/#configure-block-settings","text":"You can configure the Name of each Block by clicking on it and accessing the Block configuration panel. It is not possible to change the basic functionality of a Block, as it is defined by the Block Template. It is possible to change nearly all Template attributes as well as the associated Program and Attachments using the Template Configuration panel.","title":"Configure Block Settings"},{"location":"UI/creating-workflows/#save-the-workflow","text":"Once you have built your Workflow, you must save it by clicking on the \"Save\" button in the top right corner of the Workflow Editor. This saves the Workflow to the PROOF database, making it available for execution and further editing.","title":"Save the Workflow"},{"location":"UI/creating-workflows/#executing-the-workflow-via-workflow-editor","text":"After having saved the Workflow, you can execute it by navigating to the RUN button in the top right corner of the Workflow editor. You must enter all relevant Execution values in the pop-up execution dialog, such as Execution ID, Description, and other parameters specific to the Workflow.","title":"Executing the Workflow via Workflow Editor"},{"location":"UI/creating-workflows/#executing-the-workflow-via-monitoring-panel","text":"You can also start a saved Workflow from the Workflow Monitoring panel in the PROOF UI. Click the Workflow Monitoring menu item in the left menu bar to open the monitoring interface. Press the \"RUN Workflow\" button in the top right corner of the Workflow Monitoring interface. A Combo box appears listing all saved Workflows. Select the saved Workflow from the list and click on the \"Start\" button to initiate the execution. Enter all necessary attribute values in the pop-up execution dialog, such as Execution Label, Description, and all start values for the given Inputs. Monitor the execution progress and view results through the Workflow Monitoring interface.","title":"Executing the Workflow via Monitoring Panel"},{"location":"UI/overview/","text":"This is an overview about PROOF","title":"Overview"},{"location":"UI/using-proof-blocks/","text":"Use Blocks \u00b6 Blocks are used to create workflows in PROOF. Each Block represents a specific functionality or model that can be executed within a workflow. The Block is defined by its Template , which specifies the inputs, outputs, and execution logic of the block. There are several predefined Block Templates available in PROOF that can be used to create workflows. To use a Block in a workflow, you only need to select a Block from the available Templates list in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas. After having positioned the Block on the canvas, you can connect its inputs and outputs to other Blocks in the workflow to define the data flow between them. When selecting a Block on the canvas, you can see and configure some of its settings, e.g. the Block's visible name or color, in the Block Configuration panel that appears on the PROOF Workflow Editor . If the Workflow is complete, you can save it and execute it using the START WORKFLOW button in the right upper corner of the PROOF Workflow Editor . Alternatively, you can also start a saved Workflow from the Monitoring panel in the PROOF UI (2nd menu in the left sidebar). Use own Blocks \u00b6 It is also possible to create your own Blocks by defining new Templates in PROOF. For this, see Creating new Block Templates .","title":"Using Blocks"},{"location":"UI/using-proof-blocks/#use-blocks","text":"Blocks are used to create workflows in PROOF. Each Block represents a specific functionality or model that can be executed within a workflow. The Block is defined by its Template , which specifies the inputs, outputs, and execution logic of the block. There are several predefined Block Templates available in PROOF that can be used to create workflows. To use a Block in a workflow, you only need to select a Block from the available Templates list in the right sidebar of the PROOF Workflow Editor and drag and drop it onto the Workflow canvas. After having positioned the Block on the canvas, you can connect its inputs and outputs to other Blocks in the workflow to define the data flow between them. When selecting a Block on the canvas, you can see and configure some of its settings, e.g. the Block's visible name or color, in the Block Configuration panel that appears on the PROOF Workflow Editor . If the Workflow is complete, you can save it and execute it using the START WORKFLOW button in the right upper corner of the PROOF Workflow Editor . Alternatively, you can also start a saved Workflow from the Monitoring panel in the PROOF UI (2nd menu in the left sidebar).","title":"Use Blocks"},{"location":"UI/using-proof-blocks/#use-own-blocks","text":"It is also possible to create your own Blocks by defining new Templates in PROOF. For this, see Creating new Block Templates .","title":"Use own Blocks"},{"location":"Workflow/monitoring-workflows/","text":"On the proof UI, you can monitor Workflows by selecting the Monitoring from the menu. Workflow Monitoring \u00b6 The Workflow Monitoring is the main interface to run, execute, and stop workflows and check logs in PROOF. 1. Monitoring \u00b6 This interface allows you to monitor the status of workflows, including their execution status, logs, and other relevant information. 2. Run Workflow \u00b6 After a workflow is selected in the dropdown list, it can be executed by clicking on the \"Run\" button in the top right corner of the Execution Monitoring interface.","title":"Monitoring Workflows"},{"location":"Workflow/monitoring-workflows/#workflow-monitoring","text":"The Workflow Monitoring is the main interface to run, execute, and stop workflows and check logs in PROOF.","title":"Workflow Monitoring"},{"location":"Workflow/monitoring-workflows/#1-monitoring","text":"This interface allows you to monitor the status of workflows, including their execution status, logs, and other relevant information.","title":"1. Monitoring"},{"location":"Workflow/monitoring-workflows/#2-run-workflow","text":"After a workflow is selected in the dropdown list, it can be executed by clicking on the \"Run\" button in the top right corner of the Execution Monitoring interface.","title":"2. Run Workflow"},{"location":"Workflow/proof-workflows/","text":"PROOF Workflow Structure \u00b6 A workflow consists of a combination of workflow elements that must be conducted in a particular order and implemented using several software tools. A PROOF Workflow defines how blocks are coupled and which outputs and inputs are connected to allow data transfer. It follows a given structure that defines how blocks are connected and executed. The following images illustrate the structure of a Workflow: Creating workflows \u00b6 see: Creating Workflows Monitoring a Workflow \u00b6 see: Workflow Monitoring Configuring Workflows \u00b6 see: Workflow Configuration","title":"Workflow Structure"},{"location":"Workflow/proof-workflows/#proof-workflow-structure","text":"A workflow consists of a combination of workflow elements that must be conducted in a particular order and implemented using several software tools. A PROOF Workflow defines how blocks are coupled and which outputs and inputs are connected to allow data transfer. It follows a given structure that defines how blocks are connected and executed. The following images illustrate the structure of a Workflow:","title":"PROOF Workflow Structure"},{"location":"Workflow/proof-workflows/#creating-workflows","text":"see: Creating Workflows","title":"Creating workflows"},{"location":"Workflow/proof-workflows/#monitoring-a-workflow","text":"see: Workflow Monitoring","title":"Monitoring a Workflow"},{"location":"Workflow/proof-workflows/#configuring-workflows","text":"see: Workflow Configuration","title":"Configuring Workflows"},{"location":"Workflow/running-workflows/","text":"","title":"Running workflows"}]}